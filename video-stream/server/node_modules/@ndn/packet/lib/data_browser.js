import { Encoder, EvDecoder, NNI } from "@ndn/tlv";
import { sha256 } from "@ndn/util";
import { TT } from "./an_browser.js";
import { Component, ImplicitDigest, Name } from "./name/mod_browser.js";
import { LLSign, LLVerify } from "./security/signing_browser.js";
import { SigInfo } from "./sig-info_browser.js";
const FIELDS = Symbol("Data.FIELDS");
class Fields {
    constructor(...args) {
        this.name = new Name();
        this.content = new Uint8Array();
        this.sigInfo = new SigInfo();
        this.sigValue = new Uint8Array();
        this.contentType_ = 0;
        this.freshnessPeriod_ = 0;
        let isFinalBlock = false;
        for (const arg of args) {
            if (Name.isNameLike(arg)) {
                this.name = new Name(arg);
            }
            else if (arg instanceof Uint8Array) {
                this.content = arg;
            }
            else if (arg === Data.FinalBlock) {
                isFinalBlock = true;
            }
            else if (arg instanceof Data) {
                Object.assign(this, arg[FIELDS]);
            }
            else if (arg[ctorAssign]) {
                arg[ctorAssign](this);
            }
            else {
                throw new Error("unknown Data constructor argument");
            }
        }
        this.isFinalBlock = isFinalBlock;
    }
    get isFinalBlock() {
        return !!this.finalBlockId &&
            this.name.length > 0 &&
            this.finalBlockId.equals(this.name.at(-1));
    }
    set isFinalBlock(v) {
        if (!v) {
            this.finalBlockId = undefined;
            return;
        }
        if (this.name.length === 0) {
            throw new Error("cannot set FinalBlockId when Name is empty");
        }
        this.finalBlockId = this.name.at(-1);
    }
    get contentType() { return this.contentType_; }
    set contentType(v) { this.contentType_ = NNI.constrain(v, "ContentType"); }
    get freshnessPeriod() { return this.freshnessPeriod_; }
    set freshnessPeriod(v) { this.freshnessPeriod_ = NNI.constrain(v, "FreshnessPeriod"); }
}
const FIELD_LIST = ["name", "contentType", "freshnessPeriod", "finalBlockId", "isFinalBlock", "content", "sigInfo", "sigValue"];
const EVD = new EvDecoder("Data", TT.Data)
    .add(TT.Name, (t, { decoder }) => t.name = decoder.decode(Name), { required: true })
    .add(TT.MetaInfo, new EvDecoder("MetaInfo")
    .add(TT.ContentType, (t, { nni }) => t.contentType = nni)
    .add(TT.FreshnessPeriod, (t, { nni }) => t.freshnessPeriod = nni)
    .add(TT.FinalBlock, (t, { vd }) => t.finalBlockId = vd.decode(Component)))
    .add(TT.Content, (t, { value }) => t.content = value)
    .add(TT.DSigInfo, (t, { decoder }) => {
    t.sigInfo = decoder.decode(SigInfo);
}, { required: true })
    .add(TT.DSigValue, (t, { value, before }) => {
    t.sigValue = value;
    t.signedPortion = before;
}, { required: true });
EVD.beforeTopCallbacks.push((t, { tlv }) => t.topTlv = tlv);
/** Data packet. */
export class Data {
    /**
     * Construct from flexible arguments.
     *
     * Arguments can include:
     * - Data to copy from
     * - Name or name URI
     * - Data.ContentType(v)
     * - Data.FreshnessPeriod(v)
     * - Data.FinalBlock (must appear after Name)
     * - Uint8Array as Content
     */
    constructor(...args) {
        this[FIELDS] = new Fields(...args);
    }
    static decodeFrom(decoder) {
        const data = new Data();
        EVD.decode(data[FIELDS], decoder);
        return data;
    }
    encodeTo(encoder) {
        const f = this[FIELDS];
        if (f.topTlv) {
            encoder.encode(f.topTlv);
            return;
        }
        encoder.encode(Encoder.extract([
            TT.Data,
            Encoder.extract(this.encodeSignedPortion(), (output) => f.signedPortion = output),
            [TT.DSigValue, f.sigValue],
        ], (output) => f.topTlv = output));
    }
    encodeSignedPortion() {
        const f = this[FIELDS];
        return [
            f.name,
            [
                TT.MetaInfo, Encoder.OmitEmpty,
                f.contentType > 0 ? [TT.ContentType, NNI(f.contentType)] : undefined,
                f.freshnessPeriod > 0 ? [TT.FreshnessPeriod, NNI(f.freshnessPeriod)] : undefined,
                f.finalBlockId ? [TT.FinalBlock, f.finalBlockId] : undefined,
            ],
            f.content.byteLength > 0 ? [TT.Content, f.content] : undefined,
            f.sigInfo.encodeAs(TT.DSigInfo),
        ];
    }
    getImplicitDigest() {
        return this[FIELDS].topTlvDigest;
    }
    async computeImplicitDigest() {
        let digest = this.getImplicitDigest();
        if (!digest) {
            const f = this[FIELDS];
            if (!f.topTlv) {
                Encoder.encode(this);
            }
            digest = await sha256(f.topTlv);
            f.topTlvDigest = digest;
        }
        return digest;
    }
    getFullName() {
        const digest = this.getImplicitDigest();
        if (!digest) {
            return undefined;
        }
        return this[FIELDS].name.append(ImplicitDigest, digest);
    }
    async computeFullName() {
        await this.computeImplicitDigest();
        return this.getFullName();
    }
    /**
     * Determine if a Data can satisfy an Interest.
     * @returns a Promise that will be resolved with the result.
     */
    async canSatisfy(interest) {
        if (interest.mustBeFresh && this.freshnessPeriod <= 0) {
            return false;
        }
        if (interest.canBePrefix ? interest.name.isPrefixOf(this.name) : interest.name.equals(this.name)) {
            return true;
        }
        if (interest.name.length === this.name.length + 1 && interest.name.get(-1).is(ImplicitDigest)) {
            const fullName = this.getFullName();
            if (!fullName) {
                return interest.name.equals(await this.computeFullName());
            }
            return interest.name.equals(fullName);
        }
        return false;
    }
    async [LLSign.OP](sign) {
        const signedPortion = Encoder.encode(this.encodeSignedPortion());
        this[FIELDS].signedPortion = signedPortion;
        this.sigValue = await sign(signedPortion);
    }
    async [LLVerify.OP](verify) {
        const f = this[FIELDS];
        if (!f.sigValue) {
            throw new Error("SigValue is missing");
        }
        if (!f.signedPortion) {
            throw new Error("SignedPortion is missing");
        }
        await verify(f.signedPortion, f.sigValue);
    }
}
for (const field of FIELD_LIST) {
    Object.defineProperty(Data.prototype, field, {
        enumerable: true,
        get() { return this[FIELDS][field]; },
        set(v) {
            const f = this[FIELDS];
            f[field] = v;
            f.topTlv = undefined;
            f.topTlvDigest = undefined;
            if (field !== "sigValue") {
                f.signedPortion = undefined;
            }
        },
    });
}
const ctorAssign = Symbol("Data.ctorAssign");
(function (Data) {
    /** Constructor argument to set ContentType field. */
    function ContentType(v) {
        return {
            [ctorAssign](f) { return f.contentType = v; },
        };
    }
    Data.ContentType = ContentType;
    /** Constructor argument to set FreshnessPeriod field. */
    function FreshnessPeriod(v) {
        return {
            [ctorAssign](f) { return f.freshnessPeriod = v; },
        };
    }
    Data.FreshnessPeriod = FreshnessPeriod;
    /** Constructor argument to set the current packet as FinalBlock. */
    Data.FinalBlock = Symbol("Data.FinalBlock");
})(Data || (Data = {}));
