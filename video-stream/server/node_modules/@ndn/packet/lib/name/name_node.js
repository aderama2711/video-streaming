import { Decoder, Encoder } from "@ndn/tlv";
import { TT } from "../an_node.js";
import { Component } from "./component_node.js";
/**
 * Name.
 * This type is immutable.
 */
export class Name {
    constructor(arg1, parseComponent = Component.from) {
        let valueEncoderBufSize = 256;
        switch (true) {
            case arg1 instanceof Name: {
                const other = arg1;
                this.value = other.value;
                this.comps = other.comps;
                return;
            }
            case typeof arg1 === "string": {
                const uri = arg1;
                this.comps = uri.replace(/^(?:ndn:)?\/?/, "").split("/")
                    .filter((comp) => comp !== "").map(parseComponent);
                valueEncoderBufSize = uri.length + 4 * this.comps.length;
                break;
            }
            case Array.isArray(arg1):
                this.comps = Array.from(arg1, Component.from);
                break;
            case arg1 instanceof Uint8Array: {
                this.value = arg1;
                const comps = [];
                const decoder = new Decoder(this.value);
                while (!decoder.eof) {
                    comps.push(decoder.decode(Component));
                }
                this.comps = comps;
                return;
            }
            default: // undefined
                this.value = new Uint8Array();
                this.comps = [];
                return;
        }
        this.value = Encoder.encode(this.comps, valueEncoderBufSize);
    }
    static decodeFrom(decoder) {
        const { value } = decoder.read();
        return new Name(value);
    }
    get length() {
        return this.comps.length;
    }
    /** Retrieve i-th component. */
    get(i) {
        i = i < 0 ? i + this.length : i;
        return this.comps[i];
    }
    /**
     * Retrieve i-th component.
     * @throws i-th component does not exist.
     */
    at(i) {
        const comp = this.get(i);
        if (comp === undefined) {
            throw new Error(`component ${i} out of range`);
        }
        return comp;
    }
    /** Get URI string. */
    toString() {
        return `/${this.comps.map((comp) => comp.toString()).join("/")}`;
    }
    /** Get sub name [begin, end). */
    slice(begin, end) {
        return new Name(this.comps.slice(begin, end));
    }
    /** Get prefix of n components. */
    getPrefix(n) {
        return this.slice(0, n);
    }
    append(...args) {
        if (args.length === 2 && typeof args[0] === "object" &&
            typeof args[0].create === "function") {
            return this.append(args[0].create(args[1]));
        }
        const suffix = args;
        return new Name([...this.comps, ...suffix]);
    }
    /** Return a copy of Name with a component replaced. */
    replaceAt(i, comp) {
        const comps = [...this.comps];
        comps.splice(i, 1, comp);
        return new Name(comps);
    }
    /** Compare with other name. */
    compare(other) {
        const rhs = new Name(other);
        const commonSize = Math.min(this.length, rhs.length);
        for (let i = 0; i < commonSize; ++i) {
            const cmp = this.comps[i].compare(rhs.comps[i]);
            if (cmp !== Component.CompareResult.EQUAL) {
                return cmp;
            }
        }
        if (this.length > commonSize) {
            return Name.CompareResult.RPREFIX;
        }
        if (rhs.length > commonSize) {
            return Name.CompareResult.LPREFIX;
        }
        return Name.CompareResult.EQUAL;
    }
    /** Determine if this name equals other. */
    equals(other) {
        return this.compare(other) === Name.CompareResult.EQUAL;
    }
    /** Determine if this name is a prefix of other. */
    isPrefixOf(other) {
        const cmp = this.compare(other);
        return cmp === Name.CompareResult.EQUAL || cmp === Name.CompareResult.LPREFIX;
    }
    encodeTo(encoder) {
        encoder.prependTlv(TT.Name, this.value);
    }
}
(function (Name) {
    function isNameLike(obj) {
        return obj instanceof Name || typeof obj === "string";
    }
    Name.isNameLike = isNameLike;
    /** Name compare result. */
    let CompareResult;
    (function (CompareResult) {
        /** lhs is less than, but not a prefix of rhs */
        CompareResult[CompareResult["LT"] = -2] = "LT";
        /** lhs is a prefix of rhs */
        CompareResult[CompareResult["LPREFIX"] = -1] = "LPREFIX";
        /** lhs and rhs are equal */
        CompareResult[CompareResult["EQUAL"] = 0] = "EQUAL";
        /** rhs is a prefix of lhs */
        CompareResult[CompareResult["RPREFIX"] = 1] = "RPREFIX";
        /** rhs is less than, but not a prefix of lhs */
        CompareResult[CompareResult["GT"] = 2] = "GT";
    })(CompareResult = Name.CompareResult || (Name.CompareResult = {}));
})(Name || (Name = {}));
