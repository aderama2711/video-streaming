import { __importDefault, __importStar } from "tslib";
import { Decoder, Encoder } from "@ndn/tlv";
import { fromHex, fromUtf8, toHex, toUtf8 } from "@ndn/util";
import _cjsDefaultImport0 from "buffer-compare"; const bufferCompare = __importDefault(_cjsDefaultImport0).default;
import { TT } from "../an_browser.js";
function checkType(t) {
    return Number.isFinite(t) && t >= 0x01 && t <= 0xFFFF;
}
function assertType(t) {
    if (!checkType(t)) {
        throw new Error(`Component TLV-TYPE ${t} out of range`);
    }
}
const CHAR_ENCODE = {};
for (let b = 0x00; b <= 0xFF; ++b) {
    const s = String.fromCodePoint(b);
    CHAR_ENCODE[b] = /[\w.~-]/i.test(s) ? s : `%${toHex.TABLE[b]}`;
}
const CODEPOINT_PERCENT = "%".codePointAt(0);
const CODEPOINT_PERIOD = ".".codePointAt(0);
/**
 * Name component.
 * This type is immutable.
 */
export class Component {
    constructor(arg1 = TT.GenericNameComponent, value = new Uint8Array()) {
        if (arg1 instanceof Uint8Array) {
            this.tlv = arg1;
            const decoder = new Decoder(arg1);
            ({ type: this.type, value: this.value } = decoder.read());
            assertType(this.type);
            return;
        }
        this.type = arg1;
        assertType(this.type);
        this.value = typeof value === "string" ? toUtf8(value) : value;
        this.tlv = Encoder.encode([this.type, this.value], 10 + this.value.length);
    }
    /** TLV-LENGTH. */
    get length() {
        return this.value.length;
    }
    /** TLV-VALUE interpreted as UTF-8 string. */
    get text() {
        return fromUtf8(this.value);
    }
    static decodeFrom(decoder) {
        const { tlv } = decoder.read();
        return new Component(tlv);
    }
    /** Parse from URI representation, or return existing Component. */
    static from(input) {
        if (input instanceof Component) {
            return input;
        }
        let type = TT.GenericNameComponent;
        let posValue = 0;
        const posEqual = input.indexOf("=");
        if (posEqual >= 1) {
            const iType = Number.parseInt(input, 10);
            if (checkType(iType)) {
                type = iType;
                posValue = posEqual + 1;
            }
        }
        const value = new Uint8Array(input.length - posValue);
        let length = 0;
        let hasNonPeriods = false;
        for (let i = posValue; i < input.length;) {
            let b = input.codePointAt(i);
            hasNonPeriods ||= b !== CODEPOINT_PERIOD;
            if (b === CODEPOINT_PERCENT) {
                b = (fromHex.TABLE[input[i + 1]] << 4) | fromHex.TABLE[input[i + 2]];
                i += 3;
            }
            else {
                ++i;
            }
            value[length++] = b;
        }
        if (!hasNonPeriods && length >= 3) {
            length -= 3;
        }
        return new Component(type, value.subarray(0, length));
    }
    /** Get URI string. */
    toString() {
        let s = `${this.type}=`;
        let hasNonPeriods = false;
        for (const b of this.value) {
            hasNonPeriods ||= b !== CODEPOINT_PERIOD;
            s += CHAR_ENCODE[b];
        }
        if (!hasNonPeriods) {
            s += "...";
        }
        return s;
    }
    encodeTo(encoder) {
        encoder.encode(this.tlv);
    }
    /** Determine if component follows a naming convention. */
    is(convention) {
        return convention.match(this);
    }
    /** Convert with naming convention. */
    as(convention) {
        if (!this.is(convention)) {
            throw new Error("component does not follow convention");
        }
        return convention.parse(this);
    }
    /** Compare this component with other. */
    compare(other) {
        return Component.compare(this, other);
    }
    /** Determine if this component equals other. */
    equals(other) {
        return this.compare(other) === Component.CompareResult.EQUAL;
    }
}
(function (Component) {
    /** Component compare result. */
    let CompareResult;
    (function (CompareResult) {
        /** lhs is less than rhs */
        CompareResult[CompareResult["LT"] = -2] = "LT";
        /** lhs and rhs are equal */
        CompareResult[CompareResult["EQUAL"] = 0] = "EQUAL";
        /** lhs is greater than rhs */
        CompareResult[CompareResult["GT"] = 2] = "GT";
    })(CompareResult = Component.CompareResult || (Component.CompareResult = {}));
    function toCompareResult(diff) {
        return diff === 0 ? CompareResult.EQUAL :
            diff < 0 ? CompareResult.LT : CompareResult.GT;
    }
    /** Compare two components. */
    function compare(lhs, rhs) {
        const l = Component.from(lhs);
        const r = Component.from(rhs);
        return toCompareResult(l.type - r.type) ||
            toCompareResult(l.length - r.length) ||
            toCompareResult(bufferCompare(l.value, r.value));
    }
    Component.compare = compare;
})(Component || (Component = {}));
