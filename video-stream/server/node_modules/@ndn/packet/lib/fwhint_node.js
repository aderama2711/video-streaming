import { Encoder, EvDecoder, NNI } from "@ndn/tlv";
import { TT } from "./an_node.js";
import { Name } from "./name/mod_node.js";
const DelEVD = new EvDecoder("Delegation", TT.Delegation)
    .add(TT.Preference, () => undefined)
    .add(TT.Name, (t, { decoder }) => t.name = decoder.decode(Name), { required: true });
const DelsEVD = new EvDecoder("FwHint")
    .add(TT.Name, (t, { decoder }) => t.push(decoder.decode(Name)), { order: 1, repeat: true })
    .add(TT.Delegation, (t, { decoder }) => t.push(DelEVD.decode({}, decoder).name), { order: 1, repeat: true });
/** ForwardingHint in Interest. */
export class FwHint {
    constructor(arg) {
        this.delegations = [];
        if (Array.isArray(arg)) {
            for (const name of arg) {
                this.delegations.push(new Name(name));
            }
        }
        else if (arg instanceof FwHint) {
            this.delegations = [...arg.delegations];
        }
        else if (Name.isNameLike(arg)) {
            this.delegations = [new Name(arg)];
        }
    }
    static decodeValue(vd) {
        const t = new FwHint();
        DelsEVD.decodeValue(t.delegations, vd);
        return t;
    }
    encodeTo(encoder) {
        switch (FwHint.encodeFormat) {
            case 2017:
                encoder.prependTlv(TT.ForwardingHint, Encoder.OmitEmpty, ...this.delegations.map((name, i) => [TT.Delegation, [TT.Preference, NNI(i)], name]));
                break;
            case 2021:
                encoder.prependTlv(TT.ForwardingHint, Encoder.OmitEmpty, ...this.delegations);
                break;
        }
    }
}
(function (FwHint) {
    FwHint.encodeFormat = 2017;
    function withEncodeFormat(format, cb) {
        const prevFmt = FwHint.encodeFormat;
        FwHint.encodeFormat = format;
        try {
            cb();
        }
        finally {
            FwHint.encodeFormat = prevFmt;
        }
    }
    FwHint.withEncodeFormat = withEncodeFormat;
})(FwHint || (FwHint = {}));
