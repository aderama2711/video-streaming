{
  "name": "@ndn/packet",
  "version": "0.0.20220309-nightly-b7077af",
  "description": "NDNts: Network Layer Packets",
  "keywords": [
    "NDN",
    "Named Data Networking"
  ],
  "author": "Junxiao Shi <npm@mail1.yoursunny.com>",
  "license": "ISC",
  "files": [
    "lib"
  ],
  "type": "module",
  "main": "lib/mod_node.js",
  "module": "lib/mod_browser.js",
  "sideEffects": false,
  "homepage": "https://yoursunny.com/p/NDNts/",
  "repository": {
    "type": "git",
    "url": "https://github.com/yoursunny/NDNts.git",
    "directory": "packages/packet"
  },
  "dependencies": {
    "@ndn/tlv": "https://ndnts-nightly.ndn.today/tlv.tgz",
    "@ndn/util": "https://ndnts-nightly.ndn.today/util.tgz",
    "buffer-compare": "^1.1.1",
    "mnemonist": "^0.39.0",
    "tslib": "^2.3.1"
  },
  "types": "lib/mod.d.ts",
  "readme": "# @ndn/packet\n\nThis package is part of [NDNts](https://yoursunny.com/p/NDNts/), Named Data Networking libraries for the modern web.\n\nThis package implements **Name**, **Interest**, and **Data** types as specified in [NDN Packet Format v0.3](https://named-data.net/doc/NDN-packet-spec/0.3/).\n\n```ts\nimport { TT, Name, Component, ImplicitDigest, AltUri, Interest, Data, digestSigning } from \"@ndn/packet\";\n\n// other imports for examples\nimport { Decoder, Encoder } from \"@ndn/tlv\";\nimport { fromUtf8, toUtf8 } from \"@ndn/util\";\nimport { strict as assert } from \"node:assert\";\n```\n\n## Name Component\n\n```ts\n// Name components are immutable. Once it's created, you can never change it.\n// Construct a Component from its TLV-TYPE and TLV-VALUE.\nconst compA = new Component(TT.GenericNameComponent, Uint8Array.of(0x41));\n// Create a Component from URI representation.\nconst compB = Component.from(\"B\");\n// Typed components are supported, too.\nconst compMetadata = Component.from(\"32=metadata\");\n\n// We can retrieve TLV-TYPE, TLV-LENGTH, and TLV-VALUE.\nassert.equal(compA.type, TT.GenericNameComponent);\nassert.equal(compB.type, TT.GenericNameComponent);\nassert.equal(compMetadata.type, 0x20);\n\nassert.equal(compA.length, 1);\nassert.equal(compB.length, 1);\nassert.equal(compMetadata.length, 8);\n\nassert.deepEqual(compA.value, Uint8Array.of(0x41));\nassert.deepEqual(compB.value, Uint8Array.of(0x42));\nassert.deepEqual(compMetadata.value, Uint8Array.of(0x6D, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61));\n\n// For convenience, we can retrieve TLV-VALUE as text string, too.\nassert.equal(compA.text, \"A\");\nassert.equal(compB.text, \"B\");\nassert.equal(compMetadata.text, \"metadata\");\n\n// Components are comparable.\nassert.equal(compA.compare(compA), Component.CompareResult.EQUAL);\nassert.equal(compA.compare(compB), Component.CompareResult.LT);\nassert.equal(compB.compare(compA), Component.CompareResult.GT);\nassert.equal(compA.equals(compA), true);\nassert.equal(compA.equals(compB), false);\n```\n\n## Name\n\n```ts\n// Names, like components, are immutable.\n// Construct from URI.\nconst name1 = new Name(\"/localhost/2020=NDNts/rocks\");\n// Construct from a list of components, or strings to create components.\nconst name2 = new Name([compA, compB, \"C\", compMetadata]);\n// Name parsing functions expect URI in canonical format. They DO NOT recognize alternate/pretty\n// URI syntax other than allow omitting \"8=\" prefix of GenericNameComponent.\n\n// You can always convert a name back to its URI in canonical format.\nassert.equal(name1.toString(), \"/8=localhost/2020=NDNts/8=rocks\");\nassert.equal(name2.toString(), \"/8=A/8=B/8=C/32=metadata\");\n\n// AltUri.ofName() function allows printing a name as alternate/pretty URI syntax.\nassert.equal(AltUri.ofName(name1), \"/localhost/2020=NDNts/rocks\");\nassert.equal(AltUri.ofName(name2), \"/A/B/C/32=metadata\");\n// AltUri.ofName() from this package only recognizes 0x01, 0x02, and 0x08 types. If you are using\n// naming conventions from @ndn/naming-convention2 package, use the AltUri from that package.\n// This feature isn't in the regular name.toString(), so that it does not unnecessarily increase\n// browser bundle size in applications that do not need it.\n\n// It's crucial to know how many name components you have.\nassert.equal(name1.length, 3);\nassert.equal(name2.length, 4);\n\n// You can get an individual name component.\nconst name1comp1 = name1.get(1);\n// It would return 'undefined' if the component does not exist, so we have to check.\nif (name1comp1 === undefined) {\n  assert.fail(); // This isn't supposed to happen for this name, though.\n} else {\n  assert.equal(name1comp1.text, \"NDNts\");\n}\n\n// To save the 'undefined' check, use at(i). It throws if the component does not exist.\nassert.throws(() => name1.at(5));\nassert.equal(name1.at(1).text, \"NDNts\");\n\n// Slice the name to obtain part of it.\nconst name1sliced = name1.slice(1, 3);\nassert.equal(name1sliced.toString(), \"/2020=NDNts/8=rocks\");\n\n// Or, get the prefix.\nconst name2prefix = name2.getPrefix(3);\nassert.equal(name2prefix.toString(), \"/8=A/8=B/8=C\");\n\n// Indexing from the back is supported, too.\nassert.equal(name1.at(-1).text, \"rocks\");\nassert.equal(name1.slice(-2).toString(), \"/2020=NDNts/8=rocks\");\nassert.equal(name2.getPrefix(-1).toString(), \"/8=A/8=B/8=C\");\n\n// Names are comparable.\nconst nameAB = new Name(\"/A/B\");\nconst nameABB = new Name(\"/A/B/B\");\nconst nameABC = new Name(\"/A/B/C\");\nconst nameABD = new Name(\"/A/B/D\");\nconst nameABCD = new Name(\"/A/B/C/D\");\nassert.equal(nameABC.equals(nameABC), true);\nassert.equal(nameABC.equals(nameABD), false);\nassert.equal(nameABC.compare(nameABC), Name.CompareResult.EQUAL);\nassert.equal(nameABC.compare(nameABB), Name.CompareResult.GT);\nassert.equal(nameABC.compare(nameABD), Name.CompareResult.LT);\nassert.equal(nameABC.compare(nameABCD), Name.CompareResult.LPREFIX);\nassert.equal(nameABC.compare(nameAB), Name.CompareResult.RPREFIX);\n\n// LPREFIX means the first name is a strict prefix of the second name.\n// It implies the first name is less than the second name.\n// If you only care about the order, check if the result is less than zero.\nassert(nameABC.compare(nameABCD) < 0);\n\n// RPREFIX means the second name is a strict prefix of the first name.\n// It implies the first name is greater than the second name.\n// If you only care about the order, check if the result is greater than zero.\nassert(nameABC.compare(nameAB) > 0);\n\n// If you want to know whether a name is a prefix of another, it's EQUAL or LPREFIX.\n// But we got a faster way:\nassert.equal(nameABC.isPrefixOf(nameABC), true);\nassert.equal(nameABC.isPrefixOf(nameABCD), true);\nassert.equal(nameABC.isPrefixOf(nameAB), false);\n\n// I said names are immutable, but you can surely modify them to get a new Name.\nconst name1modified = name1.getPrefix(-1).append(\"is\", \"awesome\");\nassert(name1modified.toString(), \"/8=localhost/2020=NDNts/8=rocks/8=is/8=awesome\");\nassert(name1.toString(), \"/8=localhost/2020=NDNts/8=rocks\"); // unchanged\n```\n\n## Layer-3 Packet Types: Interest and Data\n\n```ts\n// We have an Interest type, of course.\n// You can set fields via constructor or setters.\nconst interest = new Interest(new Name(\"/A\"), Interest.CanBePrefix, Interest.MustBeFresh);\ninterest.canBePrefix = false;\ninterest.lifetime = 2000;\n\n// Encode and decode the Interest.\nconst interestWire = Encoder.encode(interest);\nconst interest2 = new Decoder(interestWire).decode(Interest);\nassert.equal(interest2.name.toString(), \"/8=A\");\n\n// We got a Data type, too.\n// You can set fields via constructor or setters.\nconst data = new Data(interest.name, Data.FreshnessPeriod(5000));\ndata.content = toUtf8(\"hello NDNts\");\n```\n\n## Signing and Verification\n\n```ts\n// Every NDN Data must be signed.\n// This package provides the low-level API, and an implementation of SHA256 digest signing.\n// Other signature types are in @ndn/keychain package.\n\n// Sign the Data. The API is asynchronous as required by WebCrypto.\nawait digestSigning.sign(data);\n\n// After signing, we can encode the Data.\nconst dataWire = Encoder.encode(data);\n\n// And then decode it.\nconst data2 = new Decoder(dataWire).decode(Data);\n\n// Data signature should be verified.\n// If the verify() function does not throw, it means the signature is good.\nawait digestSigning.verify(data);\n\n// It's very important that you do not modify the Data if you need to verify its signature.\n// Otherwise, you'll get errors or incorrect results.\n\n// After verifying, we can access the Content.\nassert.equal(fromUtf8(data2.content), \"hello NDNts\");\n```\n\n## Implicit Digest\n\n```ts\n// To obtain implicit digest, we'll have to await, because it internally uses WebCrypto, which is async.\nconst digest = await data.computeImplicitDigest();\nassert.equal(digest.length, 32);\n\n// Full names are available, too.\nconst fullName = await data2.computeFullName();\nassert.equal(fullName.length - 1, data2.name.length);\nassert(fullName.at(-1).is(ImplicitDigest));\n\n// After computation, implicit digest is cached on the Data instance,\n// so we can get them without await:\nconst digest2 = data.getImplicitDigest();\nconst fullName2 = data.getFullName();\nassert.equal(digest2, digest);\nassert(fullName2 !== undefined);\nassert.equal(fullName2.toString(), fullName.toString());\n\n// Note that you cannot modify the Data after encoding or decoding,\n// or you'll get incorrect implicit digest results.\n```\n\n## Interest-Data Matching\n\n```ts\n// data.canSatisfy(interest) determines whether a Data satisfy an Interest.\n// This is an async function because it potentially involves computing the implicit digest.\n\nassert.equal(await data.canSatisfy(interest), true);\nconst interest3 = new Interest(\"/B\");\nassert.equal(await data.canSatisfy(interest3), false);\nconst data3 = new Decoder(dataWire).decode(Data);\nconst interestWithFullName = new Interest(fullName);\nassert.equal(await data.canSatisfy(interestWithFullName), true);\n```\n"
}