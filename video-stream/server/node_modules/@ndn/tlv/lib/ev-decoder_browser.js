import { printTT } from "./string_browser.js";
const AUTO_ORDER_SKIP = 100;
function nest(evd) {
    return (target, { decoder }) => { evd.decode(target, decoder); };
}
function isCritical(tt) {
    return tt <= 0x1F || tt % 2 === 1;
}
/** TLV-VALUE decoder that understands Packet Format v0.3 evolvability guidelines. */
export class EvDecoder {
    /**
     * Constructor.
     * @param typeName type name, used in error messages.
     * @param topTT if specified, check top-level TLV-TYPE to be in this list.
     */
    constructor(typeName, topTT = []) {
        this.typeName = typeName;
        this.rules = new Map();
        this.requiredTlvTypes = new Set();
        this.nextOrder = AUTO_ORDER_SKIP;
        this.isCriticalCb = isCritical;
        /** Callbacks to receive top-level TLV before decoding TLV-VALUE. */
        this.beforeTopCallbacks = [];
        /** Callbacks before decoding TLV-VALUE. */
        this.beforeValueCallbacks = [];
        /** Callbacks after decoding TLV-VALUE. */
        this.afterValueCallbacks = [];
        /** Callbacks to receive top-level TLV after decoding TLV-VALUE. */
        this.afterTopCallbacks = [];
        this.topTT = Array.isArray(topTT) ? topTT : [topTT];
        this.unknownCb = () => false;
    }
    /**
     * Add a decoding rule.
     * @param tt TLV-TYPE to match this rule.
     * @param cb callback to handle element TLV.
     * @param options additional rule options.
     */
    add(tt, cb, options) {
        if (this.rules.has(tt)) {
            throw new Error(`TLV-TYPE ${printTT(tt)} already has a rule`);
        }
        const rule = {
            cb: cb instanceof EvDecoder ? nest(cb) : cb,
            order: this.nextOrder,
            required: false,
            repeat: false,
            ...options,
        };
        this.nextOrder += AUTO_ORDER_SKIP;
        this.rules.set(tt, rule);
        if (rule.required) {
            this.requiredTlvTypes.add(tt);
        }
        return this;
    }
    /** Set callback to determine whether TLV-TYPE is critical. */
    setIsCritical(cb) {
        this.isCriticalCb = cb;
        return this;
    }
    /** Set callback to handle unknown elements. */
    setUnknown(cb) {
        this.unknownCb = cb;
        return this;
    }
    /** Decode TLV to target object. */
    decode(target, decoder) {
        const topTlv = decoder.read();
        const { type, vd } = topTlv;
        if (this.topTT.length > 0 && !this.topTT.includes(type)) {
            throw new Error(`TLV-TYPE ${printTT(type)} is not ${this.typeName}`);
        }
        for (const cb of this.beforeTopCallbacks) {
            cb(target, topTlv);
        }
        this.decodeValue(target, vd);
        for (const cb of this.afterTopCallbacks) {
            cb(target, topTlv);
        }
        return target;
    }
    /** Decode TLV-VALUE to target object. */
    decodeValue(target, vd) {
        for (const cb of this.beforeValueCallbacks) {
            cb(target);
        }
        let currentOrder = 0;
        let currentCount = 0;
        const missingTlvTypes = new Set(this.requiredTlvTypes);
        while (!vd.eof) {
            const tlv = vd.read();
            const tt = tlv.type;
            missingTlvTypes.delete(tt);
            const rule = this.rules.get(tt);
            if (rule === undefined) {
                if (!this.unknownCb(target, tlv, currentOrder)) {
                    this.handleUnrecognized(tt, "unknown");
                }
                continue;
            }
            if (currentOrder > rule.order) {
                this.handleUnrecognized(tt, "out of order");
                continue;
            }
            if (currentOrder < rule.order) {
                currentOrder = rule.order;
                currentCount = 0;
            }
            ++currentCount;
            if (!rule.repeat && currentCount > 1) {
                throw new Error(`TLV-TYPE ${printTT(tt)} cannot repeat in ${this.typeName}`);
            }
            rule.cb(target, tlv);
        }
        if (missingTlvTypes.size > 0) {
            throw new Error(`TLV-TYPE ${Array.from(missingTlvTypes, printTT).join(",")} ${missingTlvTypes.size === 1 ? "is" : "are"} missing in ${this.typeName}`);
        }
        for (const cb of this.afterValueCallbacks) {
            cb(target);
        }
        return target;
    }
    handleUnrecognized(tt, reason) {
        if (this.isCriticalCb(tt)) {
            throw new Error(`TLV-TYPE ${printTT(tt)} is ${reason} in ${this.typeName}`);
        }
    }
}
