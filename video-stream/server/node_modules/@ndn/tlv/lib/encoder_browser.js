import { asDataView } from "@ndn/util";
function sizeofVarNum(n) {
    if (n < 0xFD) {
        return 1;
    }
    if (n <= 0xFFFF) {
        return 3;
    }
    if (n <= 0xFFFFFFFF) {
        return 5;
    }
    // JavaScript cannot reliably represent 64-bit integers
    throw new Error("VAR-NUMBER is too large");
}
function writeVarNum(room, off, n) {
    if (n < 0xFD) {
        room[off++] = n;
    }
    else if (n <= 0xFFFF) {
        room[off++] = 0xFD;
        asDataView(room).setUint16(off, n);
    }
    else {
        room[off++] = 0xFE;
        asDataView(room).setUint32(off, n);
    }
}
const BUF_INIT_SIZE = 2048;
const BUF_GROW_SIZE = 2048;
/** TLV encoder that accepts objects in reverse order. */
export class Encoder {
    constructor(initSize = BUF_INIT_SIZE) {
        this.buf = new ArrayBuffer(initSize);
        this.off = initSize;
    }
    /** Return encoding output size. */
    get size() {
        return this.buf.byteLength - this.off;
    }
    /** Obtain encoding output. */
    get output() {
        return this.slice();
    }
    /** Obtain part of encoding output. */
    slice(start = 0, length) {
        if (length === undefined) {
            // iOS would interpret length=undefined as length=0, so we need a conditional
            return new Uint8Array(this.buf, this.off + start);
        }
        return new Uint8Array(this.buf, this.off + start, length);
    }
    /**
     * Make room to prepend an object.
     * @param sizeofObject object size.
     * @returns room to write object.
     */
    prependRoom(sizeofObject) {
        if (this.off < sizeofObject) {
            this.grow(sizeofObject);
        }
        this.off -= sizeofObject;
        return this.slice(0, sizeofObject);
    }
    /** Prepend TLV-TYPE and TLV-LENGTH. */
    prependTypeLength(tlvType, tlvLength) {
        const sizeofT = sizeofVarNum(tlvType);
        const sizeofL = sizeofVarNum(tlvLength);
        const room = this.prependRoom(sizeofT + sizeofL);
        writeVarNum(room, 0, tlvType);
        writeVarNum(room, sizeofT, tlvLength);
    }
    /** Prepend TLV-VALUE. */
    prependValue(...tlvValue) {
        for (let i = tlvValue.length - 1; i >= 0; --i) {
            this.encode(tlvValue[i]);
        }
    }
    /**
     * Prepend TLV structure.
     * @param tlvType TLV-TYPE number.
     * @param omitEmpty omit TLV altogether if set to Encoder.OmitEmpty.
     * @param tlvValue TLV-VALUE objects.
     */
    prependTlv(tlvType, omitEmpty, ...tlvValue) {
        let hasOmitEmpty = false;
        if (omitEmpty) {
            if (omitEmpty === Encoder.OmitEmpty) {
                hasOmitEmpty = true;
            }
            else {
                tlvValue.unshift(omitEmpty);
            }
        }
        const sizeBefore = this.size;
        this.prependValue(...tlvValue);
        const tlvLength = this.size - sizeBefore;
        if (tlvLength > 0 || !hasOmitEmpty) {
            this.prependTypeLength(tlvType, tlvLength);
        }
    }
    /** Prepend an Encodable object. */
    encode(obj) {
        if (obj instanceof Uint8Array) {
            this.prependRoom(obj.byteLength).set(obj);
        }
        else if (typeof obj === "object" && typeof obj.encodeTo === "function") {
            obj.encodeTo(this);
        }
        else if (Array.isArray(obj)) {
            if (typeof obj[0] === "number") {
                this.prependTlv(...obj);
            }
            else {
                this.prependValue(...obj);
            }
        }
        else if (obj !== undefined) {
            throw new Error("Encoder.encode: obj is not Encodable");
        }
    }
    grow(sizeofRoom) {
        const sizeofGrow = BUF_GROW_SIZE + sizeofRoom;
        const buf = new ArrayBuffer(sizeofGrow + this.size);
        new Uint8Array(buf, sizeofGrow).set(this.output);
        this.buf = buf;
        this.off = sizeofGrow;
    }
}
(function (Encoder) {
    Encoder.OmitEmpty = Symbol("OmitEmpty");
    /** Encode a single object into Uint8Array. */
    function encode(obj, initBufSize = BUF_INIT_SIZE) {
        const encoder = new Encoder(initBufSize);
        encoder.encode(obj);
        return encoder.output;
    }
    Encoder.encode = encode;
    /** Extract the encoding output of an element while writing to a larger encoder. */
    function extract(obj, cb) {
        return {
            encodeTo(encoder) {
                const sizeBefore = encoder.size;
                encoder.encode(obj);
                cb(encoder.slice(0, encoder.size - sizeBefore));
            },
        };
    }
    Encoder.extract = extract;
})(Encoder || (Encoder = {}));
