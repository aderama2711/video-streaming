{
  "name": "@ndn/tlv",
  "version": "0.0.20220309-nightly-b7077af",
  "description": "NDNts: TLV",
  "keywords": [
    "NDN",
    "Named Data Networking"
  ],
  "author": "Junxiao Shi <npm@mail1.yoursunny.com>",
  "license": "ISC",
  "files": [
    "lib"
  ],
  "type": "module",
  "main": "lib/mod_node.js",
  "module": "lib/mod_browser.js",
  "sideEffects": false,
  "homepage": "https://yoursunny.com/p/NDNts/",
  "repository": {
    "type": "git",
    "url": "https://github.com/yoursunny/NDNts.git",
    "directory": "packages/tlv"
  },
  "dependencies": {
    "@ndn/util": "https://ndnts-nightly.ndn.today/util.tgz",
    "mnemonist": "^0.39.0",
    "tslib": "^2.3.1"
  },
  "types": "lib/mod.d.ts",
  "readme": "# @ndn/tlv\n\nThis package is part of [NDNts](https://yoursunny.com/p/NDNts/), Named Data Networking libraries for the modern web.\n\nThis package implements Type-Length-Value structure encoder and decoder as specified in [NDN Packet Format v0.3](https://named-data.net/doc/NDN-packet-spec/0.3/tlv.html).\nIt has full support for TLV evolvability guidelines.\n\n```ts\nimport { Encoder, Decoder, EvDecoder, NNI } from \"@ndn/tlv\";\n\n// other imports for examples\nimport { Name, TT as nameTT } from \"@ndn/packet\";\nimport { strict as assert } from \"node:assert\";\n```\n\n## Encoder\n\nThe **Encoder** has an internal buffer of `Uint8Array` type.\nIt prepends any encodable items to the internal buffer, and reallocates a larger buffer when necessary.\n\n```ts\n// Encode TLV object that implements EncodableObj interface:\nlet encoder = new Encoder();\nencoder.encode(new Name(\"/A\"));\n// Look at the output:\nassert.deepEqual(encoder.output, Uint8Array.of(0x07, 0x03, 0x08, 0x01, 0x41));\n\n// Prepend a TLV structure with specified TLV-TYPE and TLV-VALUE:\nencoder = new Encoder();\nencoder.encode([0xB0, Uint8Array.of(0xC0, 0xC1)]);\nassert.deepEqual(encoder.output, Uint8Array.of(0xB0, 0x02, 0xC0, 0xC1));\n\n// Prepend a non-negative integer\nencoder.encode(NNI(0x200110));\n// We are using the same Encoder instance, so it gets prepended:\nassert.deepEqual(encoder.output, Uint8Array.of(0x00, 0x20, 0x01, 0x10, 0xB0, 0x02, 0xC0, 0xC1));\n\n// Put multiple encodable items in TLV-VALUE:\nencoder = new Encoder();\nencoder.encode([0xB0, Uint8Array.of(0xC0, 0xC1), new Name(\"/A\")]);\nassert.deepEqual(encoder.output,\n  Uint8Array.of(0xB0, 0x07, 0xC0, 0xC1, 0x07, 0x03, 0x08, 0x01, 0x41));\n```\n\n## Decoder\n\nThe **Decoder** is a basic sequential decoder.\n\n```ts\n// Read Type-Length-Value manually:\nlet decoder = new Decoder(Uint8Array.of(0x08, 0x01, 0x41, 0xFF));\nconst { type, length, value } = decoder.read();\nassert.equal(type, 0x08);\nassert.equal(length, 1);\nassert.deepEqual(value, Uint8Array.of(0x41));\n// The remaining [0xFF] is still in the buffer.\n// If you continue reading, you get an error due to incomplete TLV.\nassert.throws(() => decoder.read());\n\n// Decode into TLV object:\ndecoder = new Decoder(Uint8Array.of(0x07, 0x03, 0x08, 0x01, 0x41));\nconst name = decoder.decode(Name);\nassert(name instanceof Name);\nassert.equal(name.toString(), \"/8=A\");\n```\n\n## EvDecoder\n\nThe **EvDecoder** is a decoder that is aware of TLV evolvability guidelines.\nIt's used to implement decoding functions of TLV objects, such as `Interest.decodeFrom`.\n\nSuppose we want to decode [NLSR's LSDB Dataset](https://redmine.named-data.net/projects/nlsr/wiki/LSDB_DataSet/11):\n\n```abnf\nAdjacency = ADJACENCY-TYPE TLV-LENGTH\n              Name\n              Uri\n              Cost\nUri = URI-TYPE TLV-LENGTH *VCHAR\nCost = COST-TYPE TLV-LENGTH nonNegativeInteger\n\nADJACENCY-TYPE = 0x84\nURI-TYPE = 0x8D\nCOST-TYPE = 0x8C\n```\n\n```ts\n// Declare a class to represent this type.\nclass Adjacency {\n  public name = new Name();\n  public uri = \"\";\n  public cost = 0;\n}\n\n// Declare constants for TLV-TYPE numbers.\nconst TT = {\n  ...nameTT,\n  Adjacency: 0x84,\n  Cost: 0x8C,\n  Uri: 0x8D,\n};\n\n// Create the decoder.\nconst EVD = new EvDecoder<Adjacency>(\"Adjacency\", TT.Adjacency)\n  .add(TT.Name, (t, { decoder }) => t.name = decoder.decode(Name), { required: true })\n  .add(TT.Uri, (t, { text }) => t.uri = text, { required: true })\n  .add(TT.Cost, (t, { nni }) => t.cost = nni, { required: true });\n// Each rule declares a possible sub TLV.\n// They are added in the order of expected appearance.\n// The callback receives two arguments:\n// (1) the target object we are decoding into, so that EVD instances are reusable;\n// (2) a Decoder.Tlv structure, where we can selectively access just the TLV-VALUE, the whole TLV,\n//     the TLV-VALUE as a Decoder, the whole TLV as a Decoder, etc.\n\n// Suppose we receive this encoded TLV:\nconst adjacencyWire = Uint8Array.of(\n  0x84, 0x0D,\n  0x07, 0x03, 0x08, 0x01, 0x41, // Name\n  0x8D, 0x01, 0x42, // Uri\n  0xF0, 0x00, // unrecognized non-critical TLV-TYPE, ignored\n  0x8C, 0x01, 0x80, // Cost\n);\nconst adjacencyDecoder = new Decoder(adjacencyWire);\n\n// We can decode it with the EVD.\nconst adjacency = EVD.decode(new Adjacency(), adjacencyDecoder);\nassert.equal(adjacency.name.toString(), \"/8=A\");\nassert.equal(adjacency.uri, \"B\");\nassert.equal(adjacency.cost, 128);\n```\n"
}