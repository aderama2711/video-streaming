import { __importDefault, __importStar } from "tslib";
import { Name } from "@ndn/packet";
import { fromHex } from "@ndn/util";
import _cjsDefaultImport0 from "it-pushable"; const pushable = __importDefault(_cjsDefaultImport0).default;
import _cjsDefaultImport1 from "mnemonist/multi-map.js"; const MultiMap = __importDefault(_cjsDefaultImport1).default;
import _cjsDefaultImport2 from "retry"; const retry = __importDefault(_cjsDefaultImport2).default;
/**
 * Manage advertised prefix of the forwarder.
 *
 * This class keeps track of what prefixes are announced by the owning forwarder.
 * It accepts announcements from faces attached to the forwarder, and then informs
 * each destination on what prefixes should be advertised.
 */
export class Readvertise {
    constructor(fw) {
        this.fw = fw;
        this.announcements = new MultiMap(Set);
        this.destinations = new Set();
    }
    addAnnouncement(face, name, nameHex) {
        this.announcements.set(nameHex, face);
        if (this.announcements.multiplicity(nameHex) > 1) {
            return;
        }
        this.fw.emit("annadd", name);
        for (const dest of this.destinations) {
            dest.advertise(name, nameHex);
        }
    }
    removeAnnouncement(face, name, nameHex) {
        this.announcements.remove(nameHex, face);
        if (this.announcements.multiplicity(nameHex) > 0) {
            return;
        }
        name ??= new Name(fromHex(nameHex));
        this.fw.emit("annrm", name);
        for (const dest of this.destinations) {
            dest.withdraw(name, nameHex);
        }
    }
    /**
     * Cancel timers and other I/O resources.
     * This instance should not be used after this operation.
     */
    close() {
        for (const dest of this.destinations) {
            dest.disable();
        }
    }
}
/**
 * A destination of prefix advertisement.
 *
 * Generally, a prefix advertised to a destination would cause Interests matching the prefix
 * to come to the forwarder, aka prefix registration.
 */
export class ReadvertiseDestination {
    constructor(retryOptions = {
        forever: true,
        minTimeout: 5000,
        maxTimeout: 60000,
        randomize: true,
    }) {
        this.retryOptions = retryOptions;
        this.table = new Map();
        this.queue = pushable();
        this.closed = false;
    }
    /** Enable and attach to a forwarder. */
    enable(fw) {
        this.readvertise = fw.readvertise;
        this.readvertise.destinations.add(this);
        for (const nameHex of this.readvertise.announcements.keys()) {
            this.queue.push(nameHex);
        }
        void this.process();
    }
    /**
     * Disable and detach from forwarder.
     *
     * Once detached, this instance is no longer usable.
     */
    disable() {
        this.readvertise?.destinations.delete(this);
        this.readvertise = undefined;
        for (const [nameHex, record] of this.table) {
            this.queue.push(nameHex);
            record.status = ReadvertiseDestination.Status.WITHDRAWING;
        }
        this.queue.end();
        this.closed = true;
    }
    /** Set a prefix to be advertised. */
    advertise(name, nameHex) {
        let record = this.table.get(nameHex);
        if (!record) {
            record = {
                name,
                status: ReadvertiseDestination.Status.ADVERTISING,
                state: this.makeState(name, nameHex),
            };
            this.table.set(nameHex, record);
        }
        record.status = ReadvertiseDestination.Status.ADVERTISING;
        this.restart(nameHex, record);
    }
    /** Set a prefix to be withdrawn. */
    withdraw(name, nameHex) {
        void name;
        const record = this.table.get(nameHex);
        if (!record) {
            return;
        }
        record.status = ReadvertiseDestination.Status.WITHDRAWING;
        this.restart(nameHex, record);
    }
    restart(nameHex, record) {
        record.retry?.stop();
        record.retry = retry.operation(this.retryOptions);
        record.retry.attempt(() => {
            if (this.closed) {
                record.retry.stop();
            }
            else {
                this.queue.push(nameHex);
            }
        });
    }
    async process() {
        for await (const nameHex of this.queue) {
            const record = this.table.get(nameHex);
            if (!record) {
                continue;
            }
            const { name, status, retry, state } = record;
            switch (status) {
                case ReadvertiseDestination.Status.ADVERTISING:
                    try {
                        await this.doAdvertise(name, state, nameHex);
                        if (record.status === ReadvertiseDestination.Status.ADVERTISING) {
                            record.status = ReadvertiseDestination.Status.ADVERTISED;
                            retry.stop();
                        }
                    }
                    catch (err) {
                        retry.retry(err);
                    }
                    break;
                case ReadvertiseDestination.Status.WITHDRAWING:
                    try {
                        await this.doWithdraw(record.name, state, nameHex);
                        if (record.status === ReadvertiseDestination.Status.WITHDRAWING) {
                            record.status = ReadvertiseDestination.Status.WITHDRAWN;
                            retry.stop();
                            this.table.delete(nameHex);
                        }
                    }
                    catch (err) {
                        retry.retry(err);
                    }
                    break;
            }
        }
    }
    /** Create per-prefix state. */
    makeState(name, nameHex) {
        void name;
        void nameHex;
        return {};
    }
}
(function (ReadvertiseDestination) {
    let Status;
    (function (Status) {
        Status[Status["ADVERTISING"] = 0] = "ADVERTISING";
        Status[Status["ADVERTISED"] = 1] = "ADVERTISED";
        Status[Status["WITHDRAWING"] = 2] = "WITHDRAWING";
        Status[Status["WITHDRAWN"] = 3] = "WITHDRAWN";
    })(Status = ReadvertiseDestination.Status || (ReadvertiseDestination.Status = {}));
})(ReadvertiseDestination || (ReadvertiseDestination = {}));
