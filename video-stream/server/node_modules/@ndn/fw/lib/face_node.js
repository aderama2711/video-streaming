import { __importDefault, __importStar } from "tslib";
import { Data, Interest, Nack, Name } from "@ndn/packet";
import { toHex } from "@ndn/util";
import _cjsDefaultImport0 from "mnemonist/multi-set.js"; const MultiSet = __importDefault(_cjsDefaultImport0).default;
import { EventEmitter } from "node:events";
import _cjsDefaultImport1 from "p-fifo"; const Fifo = __importDefault(_cjsDefaultImport1).default;
import { buffer, filter, pipeline, tap } from "streaming-iterables";
function duplexFromRxTx(rxtx) {
    return (iterable) => {
        const rxtxD = rxtx;
        if (typeof rxtxD.duplex === "function") {
            return rxtxD.duplex(iterable);
        }
        const rxtxS = rxtx;
        rxtxS.tx(iterable);
        return rxtxS.rx;
    };
}
function computeAnnouncement(name, announcement) {
    switch (typeof announcement) {
        case "number":
            return name.getPrefix(announcement);
        case "boolean":
            return announcement ? name : undefined;
    }
    return new Name(announcement);
}
export class FaceImpl extends EventEmitter {
    constructor(fw, rxtx, attributes) {
        super();
        this.fw = fw;
        this.rxtx = rxtx;
        this.routes = new MultiSet();
        this.announcements = new MultiSet();
        this.running = true;
        this.txQueue = new Fifo();
        this.txQueueLength = 0;
        this.handleLowerUp = () => {
            this.emit("up");
        };
        this.handleLowerDown = () => {
            this.emit("down");
        };
        this.rxLoop = async (input) => {
            for await (const pkt of filter(() => this.running, input)) {
                switch (true) {
                    case pkt.l3 instanceof Interest: {
                        this.fw[pkt.cancel ? "cancelInterest" : "processInterest"](this, pkt);
                        break;
                    }
                    case pkt.l3 instanceof Data: {
                        this.fw.processData(this, pkt);
                        break;
                    }
                    case pkt.l3 instanceof Nack: {
                        this.fw.processNack(this, pkt);
                        break;
                    }
                }
            }
            this.close();
        };
        this.attributes = {
            local: false,
            advertiseFrom: true,
            routeCapture: true,
            ...rxtx.attributes,
            ...attributes,
        };
        fw.emit("faceadd", this);
        fw.faces.add(this);
        void pipeline(() => this.txLoop(), buffer(this.fw.opts.faceTxBuffer), tap((pkt) => fw.emit("pkttx", this, pkt)), duplexFromRxTx(rxtx), tap((pkt) => fw.emit("pktrx", this, pkt)), buffer(this.fw.opts.faceRxBuffer), this.rxLoop);
        rxtx.on?.("up", this.handleLowerUp);
        rxtx.on?.("down", this.handleLowerDown);
    }
    close() {
        if (!this.running) {
            return;
        }
        this.running = false;
        this.rxtx.off?.("up", this.handleLowerUp);
        this.rxtx.off?.("down", this.handleLowerDown);
        this.fw.faces.delete(this);
        for (const nameHex of this.routes.keys()) {
            this.fw.fib.delete(this, nameHex);
        }
        for (const nameHex of this.announcements.keys()) {
            this.fw.readvertise.removeAnnouncement(this, undefined, nameHex);
        }
        void this.txQueue.push(false);
        this.emit("close");
        this.fw.emit("facerm", this);
    }
    toString() {
        return this.attributes.describe ?? "FwFace";
    }
    hasRoute(nameInput) {
        const name = new Name(nameInput);
        return this.routes.has(toHex(name.value));
    }
    addRoute(nameInput, announcement = true) {
        const name = new Name(nameInput);
        const nameHex = toHex(name.value);
        this.fw.emit("prefixadd", this, name);
        this.routes.add(nameHex);
        if (this.routes.count(nameHex) === 1) {
            this.fw.fib.insert(this, nameHex, this.attributes.routeCapture);
        }
        const ann = computeAnnouncement(name, announcement);
        if (ann) {
            this.addAnnouncement(ann);
        }
    }
    removeRoute(nameInput, announcement = true) {
        const name = new Name(nameInput);
        const nameHex = toHex(name.value);
        const ann = computeAnnouncement(name, announcement);
        if (ann) {
            this.removeAnnouncement(ann);
        }
        this.routes.remove(nameHex);
        if (this.routes.count(nameHex) === 0) {
            this.fw.fib.delete(this, nameHex);
        }
        this.fw.emit("prefixrm", this, name);
    }
    addAnnouncement(nameInput, nameHex) {
        if (!this.attributes.advertiseFrom) {
            return;
        }
        const name = new Name(nameInput);
        nameHex ??= toHex(name.value);
        this.announcements.add(nameHex);
        if (this.announcements.count(nameHex) === 1) {
            this.fw.readvertise.addAnnouncement(this, name, nameHex);
        }
    }
    removeAnnouncement(nameInput, nameHex) {
        if (!this.attributes.advertiseFrom) {
            return;
        }
        const name = new Name(nameInput);
        nameHex ??= toHex(name.value);
        this.announcements.remove(nameHex);
        if (this.announcements.count(nameHex) === 0) {
            this.fw.readvertise.removeAnnouncement(this, name, nameHex);
        }
    }
    /** Transmit a packet on the face. */
    send(pkt) {
        if (!this.running) {
            return;
        }
        void (async () => {
            ++this.txQueueLength;
            await this.txQueue.push(pkt);
            --this.txQueueLength;
        })();
    }
    async *txLoop() {
        while (true) {
            const pkt = await this.txQueue.shift();
            if (!this.running || pkt === false) {
                break;
            }
            yield pkt;
        }
        while (!this.txQueue.isEmpty()) {
            void this.txQueue.shift();
        }
        this.close();
    }
}
