import { __importDefault, __importStar } from "tslib";
import { Data, digestSigning } from "@ndn/packet";
import { assert } from "@ndn/util";
import _cjsDefaultImport0 from "mnemonist/default-map.js"; const DefaultMap = __importDefault(_cjsDefaultImport0).default;
import _cjsDefaultImport1 from "p-defer"; const pDefer = __importDefault(_cjsDefaultImport1).default;
import { getIterator } from "streaming-iterables";
import { defaultSegmentConvention } from "../convention_node.js";
/** Produce Data for requested segment. */
export class DataProducer {
    constructor(source, prefix, { segmentNumConvention = defaultSegmentConvention, contentType = 0, freshnessPeriod = 60000, signer = digestSigning, }) {
        this.source = source;
        this.prefix = prefix;
        this.processInterest = (interest) => {
            const segmentNum = this.parseInterest(interest);
            return this.getData(segmentNum);
        };
        this.segmentNumConvention = segmentNumConvention;
        this.contentType = Data.ContentType(contentType);
        this.freshnessPeriod = Data.FreshnessPeriod(freshnessPeriod);
        this.signer = signer;
    }
    async *listData() {
        for (let i = 0;; ++i) {
            const data = await this.getData(i);
            if (!data) {
                break;
            }
            yield data;
        }
    }
    parseInterest({ name, canBePrefix }) {
        if (this.prefix.length + 1 === name.length && this.prefix.isPrefixOf(name)) {
            const lastComp = name.at(-1);
            if (this.segmentNumConvention.match(lastComp)) {
                return this.segmentNumConvention.parse(name.at(-1));
            }
            throw new Error("invalid Interest name");
        }
        if (canBePrefix && name.isPrefixOf(this.prefix)) {
            return 0;
        }
        throw new Error("invalid Interest name");
    }
    async makeData({ i, final, payload }) {
        const data = new Data(this.prefix.append(this.segmentNumConvention, i), this.contentType, this.freshnessPeriod, payload);
        if (typeof final === "number") {
            data.finalBlockId = this.segmentNumConvention.create(final);
        }
        await this.signer.sign(data);
        return data;
    }
    close() {
        this.source.close?.();
    }
}
/** Read from a sequential ChunkSource, and produce Data into a buffer. */
class SequentialDataProducer extends DataProducer {
    constructor(source, prefix, opts = {}) {
        super(source, prefix, opts);
        this.requested = -1;
        this.final = Infinity;
        this.buffer = new Map();
        this.waitlist = new DefaultMap(() => pDefer());
        this.generator = this.listChunks();
        void this.produce(opts);
    }
    async getData(i) {
        if (i > this.final) {
            return undefined;
        }
        if (i > this.requested) {
            this.requested = i;
            this.pause?.resolve();
        }
        const data = this.buffer.get(i);
        if (data) {
            return data;
        }
        await this.waitlist.get(i).promise;
        return this.buffer.get(i);
    }
    async *listChunks() {
        const iterator = getIterator(this.source.listChunks());
        try {
            while (true) {
                const { done, value } = await iterator.next();
                if (done) {
                    return false;
                }
                yield value;
            }
        }
        finally {
            void iterator.return?.();
        }
    }
    async produce({ bufferBehind = Infinity, bufferAhead = 16 }) {
        let i = -1;
        while (true) {
            const { done, value: chunk } = await this.generator.next();
            if (done) {
                break;
            }
            ++i;
            assert(chunk.i === i, "unexpected chunk number");
            if (i > this.requested + bufferAhead) {
                this.pause = pDefer();
                await this.pause.promise;
                this.pause = undefined;
            }
            const data = await this.makeData(chunk);
            this.buffer.set(i, data);
            if (Number.isFinite(bufferBehind)) {
                this.buffer.delete(i - bufferAhead - bufferBehind);
            }
            const w = this.waitlist.peek(i);
            if (w) {
                this.waitlist.delete(i);
                w.resolve();
            }
        }
        this.final = i;
    }
    close() {
        super.close();
        void this.generator.return(false);
        for (const w of this.waitlist.values()) {
            w.resolve();
        }
        this.pause?.resolve();
    }
}
/** Produce Data from a ChunkSource that supports on-demand generation. */
class OnDemandDataProducer extends DataProducer {
    constructor(source, prefix, opts = {}) {
        super(source, prefix, opts);
        assert(typeof source.getChunk === "function");
    }
    async getData(i) {
        const chunk = await this.source.getChunk(i);
        if (!chunk) {
            return undefined;
        }
        return this.makeData(chunk);
    }
}
(function (DataProducer) {
    /** Create a DataProducer suitable for the ChunkSource. */
    function create(source, prefix, opts = {}) {
        if (typeof source.getChunk === "function") {
            return new OnDemandDataProducer(source, prefix, opts);
        }
        return new SequentialDataProducer(source, prefix, opts);
    }
    DataProducer.create = create;
    /** Produce all Data packets from a ChunkSource. */
    function listData(source, prefix, opts = {}) {
        return create(source, prefix, {
            ...opts,
            bufferBehind: 0,
            bufferAhead: 0,
        }).listData();
    }
    DataProducer.listData = listData;
})(DataProducer || (DataProducer = {}));
