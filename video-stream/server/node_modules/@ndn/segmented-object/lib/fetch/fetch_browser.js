import { __importDefault, __importStar } from "tslib";
import { Name } from "@ndn/packet";
import { assert } from "@ndn/util";
import _cjsDefaultImport0 from "event-iterator"; const EventIterator = __importDefault(_cjsDefaultImport0).default;
import { collect, map, writeToStream } from "streaming-iterables";
import { Fetcher } from "./fetcher_browser.js";
import { Reorder } from "./reorder_browser.js";
class FetchResult {
    constructor(name, opts) {
        this.name = name;
        this.opts = opts;
    }
    get count() { return this.ctx?.count ?? 0; }
    startFetcher() {
        assert(!this.ctx, "fetch.Result is already used");
        const ctx = new Fetcher(this.name, this.opts);
        this.ctx = ctx;
        return new EventIterator(({ push, stop, fail, on }) => {
            let resume;
            on("highWater", () => { resume = ctx.pause(); });
            on("lowWater", () => { resume?.(); });
            ctx.on("segment", push);
            ctx.on("end", stop);
            ctx.on("error", fail);
            return () => {
                resume?.();
                ctx.off("segment", push);
                ctx.off("end", stop);
                ctx.off("error", fail);
            };
        });
    }
    unordered() {
        return map(({ data }) => data, this.startFetcher());
    }
    async *ordered() {
        const reorder = new Reorder(this.opts.segmentRange?.[0]);
        for await (const { segNum, data } of this.startFetcher()) {
            const ordered = reorder.push(segNum, data);
            yield* ordered;
        }
        assert(reorder.empty);
    }
    chunks() {
        return map((data) => data.content, this.ordered());
    }
    pipe(dest) {
        return writeToStream(dest, this.chunks());
    }
    async startPromise() {
        const chunks = await collect(this.chunks());
        const totalLength = chunks.map((chunk) => chunk.length).reduce((a, b) => a + b);
        const output = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
            output.set(chunk, offset);
            offset += chunk.length;
        }
        assert.equal(offset, totalLength);
        return output;
    }
    // eslint-disable-next-line unicorn/no-thenable
    then(onfulfilled, onrejected) {
        this.promise ??= this.startPromise();
        return this.promise.then(onfulfilled, onrejected);
    }
    [Symbol.asyncIterator]() {
        return this.ordered()[Symbol.asyncIterator]();
    }
}
/** Fetch a segment object as AsyncIterable of payload. */
export function fetch(name, opts = {}) {
    return new FetchResult(new Name(name), opts);
}
