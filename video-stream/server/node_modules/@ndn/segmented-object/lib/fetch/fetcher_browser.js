import { CancelInterest, Forwarder, FwPacket } from "@ndn/fw";
import { Data, Interest } from "@ndn/packet";
import { EventEmitter } from "events";
import { defaultSegmentConvention } from "../convention_browser.js";
import { FetchLogic } from "./logic_browser.js";
/** Fetch Data packets as guided by FetchLogic. */
export class Fetcher extends EventEmitter {
    constructor(name, opts) {
        super();
        this.name = name;
        this.opts = opts;
        this.count_ = 0;
        this.rx = async (iterable) => {
            for await (const { l3, token } of iterable) {
                if (l3 instanceof Data && typeof token === "number" && l3.contentType === 0) {
                    void this.handleData(l3, token);
                }
            }
        };
        this.handleAbort = () => {
            this.fail(new Error("abort"));
        };
        this.logic = new FetchLogic(opts);
        this.logic.on("end", () => { this.emit("end"); this.close(); });
        this.logic.on("exceedRetxLimit", (segNum) => {
            this.fail(new Error(`cannot retrieve segment ${segNum}`));
        });
        this.face = (opts.endpoint?.fw ?? Forwarder.getDefault()).addFace({
            rx: this.tx(),
            tx: this.rx,
        }, {
            describe: opts.describe ?? `fetch(${name})`,
        });
        opts.signal?.addEventListener("abort", this.handleAbort);
    }
    /** Number of segments retrieved so far. */
    get count() { return this.count_; }
    close() {
        this.on("error", () => undefined); // ignore further errors
        this.opts.signal?.removeEventListener("abort", this.handleAbort);
        this.logic.close();
        this.face.close();
    }
    pause() {
        return this.logic.pause();
    }
    tx() {
        const { segmentNumConvention = defaultSegmentConvention, modifyInterest, lifetimeAfterRto = 1000, } = this.opts;
        const modify = Interest.makeModifyFunc(modifyInterest);
        return this.logic.outgoing(({ segNum, rto }) => {
            const interest = new Interest(this.name.append(segmentNumConvention, segNum), Interest.Lifetime(rto + lifetimeAfterRto));
            modify(interest);
            return FwPacket.create(interest, segNum);
        }, ({ interest: { l3, token } }) => new CancelInterest(l3, token));
    }
    async handleData(data, segNum) {
        const now = this.logic.now();
        try {
            await this.opts.verifier?.verify(data);
        }
        catch (err) {
            this.fail(new Error(`cannot verify segment ${segNum}: ${err}`));
            return;
        }
        this.logic.satisfy(segNum, now);
        if (data.isFinalBlock) {
            this.logic.setFinalSegNum(segNum);
        }
        else {
            let segmentConvention;
            if (data.finalBlockId?.is((segmentConvention = this.opts.segmentNumConvention ?? defaultSegmentConvention))) {
                this.logic.setFinalSegNum(data.finalBlockId.as(segmentConvention), true);
            }
        }
        ++this.count_;
        this.emit("segment", { segNum, data });
    }
    fail(err) {
        setTimeout(() => {
            this.emit("error", err);
            this.close();
        }, 0);
    }
}
