import { __importDefault, __importStar } from "tslib";
import { assert } from "@ndn/util";
import _cjsDefaultImport0 from "hirestime"; const hirestime = __importDefault(_cjsDefaultImport0).default;
import _cjsDefaultImport1 from "mnemonist/default-weak-map.js"; const DefaultWeakMap = __importDefault(_cjsDefaultImport1).default;
import { EventEmitter } from "events";
import _cjsDefaultImport2 from "p-defer"; const pDefer = __importDefault(_cjsDefaultImport2).default;
import { RttEstimator } from "./rtt-estimator_browser.js";
import { TcpCubic } from "./tcp-cubic_browser.js";
import { TokenLimiter } from "./token-limiter_browser.js";
const tokenLimiters = new DefaultWeakMap((ca) => {
    const tl = new TokenLimiter();
    tl.capacity = ca.cwnd;
    ca.on("cwndupdate", (cwnd) => tl.capacity = cwnd);
    return tl;
});
class SegState {
    constructor(segNum) {
        this.segNum = segNum;
        this.nRetx = 0;
        this.txTime = 0;
        this.rto = 0;
    }
    get isRetx() { return this.nRetx > 0; }
}
const UNBLOCK = Symbol("UNBLOCK");
/** Congestion control logic. */
export class FetchLogic extends EventEmitter {
    constructor({ rtte, ca = new TcpCubic(), segmentRange = [0, undefined], estimatedFinalSegNum, retxLimit = 15, }) {
        super();
        /** Internal clock. */
        this.now = hirestime();
        this.pending = new Map();
        this.retxQueue = new Set();
        this.hiDataSegNum = 0;
        this.cwndDecreaseSegNum = -1;
        this.running = true;
        this.processCancels = false;
        this.rtte = rtte instanceof RttEstimator ? rtte : new RttEstimator(rtte);
        this.ca = ca;
        this.tl = tokenLimiters.get(this.ca);
        this.retxLimit = retxLimit;
        this.hiInterestSegNum = segmentRange[0] - 1;
        this.finalSegNum = (segmentRange[1] ?? Number.MAX_SAFE_INTEGER) - 1;
        assert(this.hiInterestSegNum < this.finalSegNum, "invalid segmentRange");
        this.estimatedFinalSegNum = estimatedFinalSegNum ?? this.finalSegNum;
    }
    /** Abort. */
    close() {
        this.running = false;
        this.emit(UNBLOCK);
        for (const [, { rtoExpiry }] of this.pending) {
            clearTimeout(rtoExpiry);
        }
        this.tl.put(this.pending.size - this.retxQueue.size);
    }
    /**
     * Pause outgoing Interests, for backpressure from Data consumer.
     * Return a function for resuming.
     */
    pause() {
        const defer = pDefer();
        this.paused = defer.promise;
        return () => {
            defer.resolve();
            this.paused = undefined;
        };
    }
    /** Generate stream of outgoing requests. */
    async *outgoing(makeInterest, cancelInterest) {
        while (this.running) {
            await this.paused;
            await this.tl.take();
            if (!this.running) {
                this.tl.put();
                break;
            }
            if (this.processCancels) {
                for (const [segNum, req] of this.pending) {
                    if (segNum <= this.finalSegNum) {
                        continue;
                    }
                    this.pending.delete(segNum);
                    if (!this.retxQueue.delete(segNum)) {
                        clearTimeout(req.rtoExpiry);
                        this.tl.put();
                        yield cancelInterest(req);
                    }
                }
                this.processCancels = false;
            }
            if (this.retxQueue.size > 0) {
                let segNum;
                // eslint-disable-next-line no-unreachable-loop
                for (segNum of this.retxQueue) {
                    this.retxQueue.delete(segNum);
                    break;
                }
                const req = this.pending.get(segNum);
                assert(!!req);
                ++req.nRetx;
                yield this.prepareRequest(req, makeInterest);
                continue;
            }
            if (this.hiInterestSegNum < this.estimatedFinalSegNum) {
                const segNum = ++this.hiInterestSegNum;
                const req = new SegState(segNum);
                this.pending.set(segNum, req);
                yield this.prepareRequest(req, makeInterest);
                continue;
            }
            this.tl.put();
            if (this.pending.size === 0 && this.estimatedFinalSegNum >= this.finalSegNum) {
                this.emit("end");
                break;
            }
            await new Promise((r) => this.once(UNBLOCK, r));
        }
    }
    prepareRequest(req, makeInterest) {
        req.txTime = this.now();
        req.rto = this.rtte.rto;
        req.rtoExpiry = setTimeout(() => this.rtoTimeout(req.segNum), req.rto);
        req.interest = makeInterest(req);
        return req.interest;
    }
    /**
     * Notify a request has been satisfied.
     * @param now reading of `this.now()` at packet arrival (e.g. before verification)
     */
    satisfy(segNum, now = this.now()) {
        const req = this.pending.get(segNum);
        if (!req) {
            return;
        }
        this.pending.delete(segNum);
        if (!this.retxQueue.delete(segNum)) {
            clearTimeout(req.rtoExpiry);
            this.tl.put();
        }
        if (!req.isRetx) {
            const rtt = now - req.txTime;
            this.rtte.push(rtt, this.tl.nTaken + 1);
        }
        this.ca.increase(now, this.rtte.sRtt);
        this.hiDataSegNum = Math.max(this.hiDataSegNum, segNum);
        if (this.hiDataSegNum === this.estimatedFinalSegNum && this.estimatedFinalSegNum < this.finalSegNum) {
            ++this.estimatedFinalSegNum;
        }
        this.emit(UNBLOCK);
    }
    rtoTimeout(segNum) {
        const req = this.pending.get(segNum);
        assert(!!req);
        this.tl.put();
        if (segNum > this.finalSegNum) {
            return;
        }
        if (this.hiDataSegNum > this.cwndDecreaseSegNum) {
            this.ca.decrease(this.now());
            this.rtte.backoff();
            this.cwndDecreaseSegNum = this.hiInterestSegNum;
        }
        if (req.nRetx >= this.retxLimit) {
            this.pending.delete(segNum);
            this.emit("exceedRetxLimit", segNum);
        }
        else {
            this.retxQueue.add(segNum);
        }
        this.emit(UNBLOCK);
    }
    /**
     * Update final segment number (inclusive) when it becomes known.
     * Increasing this above opts.segmentRange[1] or a previous value has no effect.
     */
    setFinalSegNum(finalSegNum, estimated = false) {
        if (finalSegNum >= this.finalSegNum) {
            return;
        }
        this.estimatedFinalSegNum = finalSegNum;
        if (!estimated) {
            this.finalSegNum = finalSegNum;
            this.processCancels = true;
        }
        this.emit(UNBLOCK);
    }
}
